\documentclass[parskip=full]{scrartcl}
\usepackage[T1]{fontenc}    % avoid garbled Unicode text in pdf
\usepackage[utf8]{inputenc} % use utf8 file encoding for TeX sources
\usepackage[german]{babel}  % german hyphenation, quotes, etc
\usepackage{hyperref}       % detailed hyperlink/pdf configuration
\hypersetup{                % ‘texdoc hyperref‘ for options
pdftitle={PSE: Entwicklung eines relationalen Debuggers - Pflichtenheft},%
,%
}
\usepackage{graphicx}       % provides commands for including figures
\usepackage{csquotes}       % provides \enquote{} macro for "quotes"
\usepackage[nonumberlist]{glossaries}     % provides glossary commands
\usepackage{enumitem}
\usepackage{xcolor}
\newcommand\frage[1]{\textcolor{red}{#1}}


\newglossaryentry{Debugger}
{
	name={Debugger},
	description={Ein Debugger ist ein Werkzeug zum Diagnostizieren und Auffinden von Fehlern in Computerprogrammen}
}
\newglossaryentry{Variableninspektor}
{
	name={Variableninspektor},
	plural={Variableninspektoren},
	description={Zeigt die Variablen des Programms und deren Belegung an}
}
\newglossaryentry{Relationale Eigenschaft}
{
	name={Relationale Eigenschaft},
	plural={Relationale Eigenschaften},
	description={ Relationale Eigenschaften sind solche Eigenschaften, die sich auf mindestens zwei Programmausführungen beziehen. Dabei können diese sich auf Variablen aus den verschiedenen Programmläufen beziehen und diese miteinander in Verbindung setzen, etwa ob eine Variable größer als eine andere ist}
}
\newglossaryentry{Interpreter}
{
	name={Interpreter},
	description={Teil des Produkts, welches die definierte Sprache ausführt}
}
\newglossaryentry{Tooltip}
{
	name={Tooltip},
	plural={Tooltips},
	description={Zeigt eine Beschreibung zu einem Element der Benutzeroberfläche}
}

\newglossaryentry{Einzelschritt}
{
	name={Einzelschritt},
	plural={Einzelschritte},
	description={Ein Einzelschritt entspricht einem ausgeführten Befehl}
}
\newglossaryentry{Schritt}
{
  name={Schritt},
  plural={Schritte},
  description={Siehe Einzelschritt. Die Anzahl ausgeführter Befehle entspricht der Schrittgröße}
}
%\newglossaryentry{Schrittgröße}
%{
%	name={Schrittgröße},
%	description={Die vom Benutzer anzugebende Schrittgröße bestimmt die pro Schritt ausgeführten Befehle. Hierbei zählt jeder Befehl einzeln und in %Methoden und Funktionen werden alle Befehle gezählt, statt die Methode bzw. Funktion als einen Befehl zu betrachten}
%}
\newglossaryentry{Step-Out}
{
	name={Step-Out},
	description={Springt bis zum Ende der aktuell ausgeführten Funktion. Befindet sich der Debugger in der main-Funktion, wird das Programm fertig gedebuggt}
}
\newglossaryentry{Step-Over}
{
	name={Step-Over},
	description={Ist der Befehl in der aktuellen Zeile ein Methodenaufruf, wird das Programm bis zum Ende dieser Methode gedebuggt. Ist der Befehl eine einzelne Ausführung,
	wird diese wie bei einem Einzelschritt ausgeführt}
}
\newglossaryentry{Breakpoint}
{
	name={Breakpoint},
	plural={Breakpoints},
	description={Erreicht das Produkt einen Breakpoint, stoppt es an dieser Stelle das Debuggen}
}
\newglossaryentry{bedingter Breakpoint}
{
	name={bedingter Breakpoint},
	plural={bedingte Breakpoints},
	user1={bedingten Breakpoints},
	user2={Bedingte Breakpoints},
	description={Der Benutzer kann Relationen zwischen Variablen der zu debuggenden Programme angeben. Sobald diese Relation zutrifft, stoppt das Produkt das Debuggen,
	auch wenn aktuell ein Schritt ausgeführt wird, der weiter springen würde. Weiteres dazu ist in Kapitel 12 zu finden}
}
\newglossaryentry{Watch-Expression}
{
	name={Watch-Expression},
	plural={Watch-Expressions},
	description={Der Benutzer kann Ausdrücke, die sich auf Variablen in den zu debuggenden Programmen beziehen, als Watch-Expressions angeben. Er wird dann beim Debuggen dauerhaft über den aktuellen Zustand des ausgewerteten Ausdrucks informiert. Weiteres dazu ist in Kapitel 12 zu finden}
}
\newglossaryentry{Debugmodus}
{
	name={Debugmodus},
	description={Das Produkt befindet sich im Debugmodus, sobald der Benutzer Start auswählt. Im Debugmodus können Eingabevariablen und die zu debuggenden Programme nicht
	mehr geändert werden}
}
\newglossaryentry{Editiermodus}
{
	name={Editiermodus},
	description={Das Produkt befindet sich im Editiermodus, bevor der Benutzer den Debugmodus startet, und nachdem das Debuggen abgeschlossen ist. Im Editiermodus
	können Eingabevariablen und die zu debuggenden Programme geändert werden}
}
\newglossaryentry{Konfigurationsdatei}
{
	name={Konfigurationsdatei},
	plural={Konfigurationsdateien},
	description={Der Benutzer kann Konfigurationsdateien bezüglich eines Durchlaufs des Produkts erstellen. Diese Dateien enthalten die zu debuggenden Programme,
	Breakpoints, Watch-Expressions, Eingabevariablen, Schrittgrößen und die Stelle, an der das Debuggen eventuell unterbrochen wurde}
}



\let\glsplgen\glsuseri
\let\glsplcap\glsuserii

\makeglossaries

\font\myfont=cmr12 at 20pt

\title{
	\vspace{2cm}
	\myfont 
	Praxis der Softwareentwicklung:\\ 
	Entwicklung eines relationalen Debuggers\\
}
\subtitle{
	\vspace{1cm}
	\myfont
	Pflichtenheft
}
\author{
	\vspace{1cm} \\
	Benedikt Wagner\\
	\texttt{udpto@student.kit.edu}
	\and \vspace{1cm} \\ Chiara Staudenmaier\\
	\texttt{uzhtd@student.kit.edu}
	\and Etienne Brunner\\
	\texttt{urmlp@student.kit.edu}
	\and Joana Plewnia\\
	\texttt{uhfpm@student.kit.edu} 
	\and Pascal Zwick\\
	\texttt{uyqpk@student.kit.edu}
	\and Ulla Scheler\\
	\texttt{ujuhe@student.kit.edu}
	\vspace{1cm}
	\and Betreuer: Mihai Herda, Michael Kirsten
	\vspace{4cm}
}


\begin{document}
\clearpage
\maketitle
\pagenumbering{gobble}
\newpage

\tableofcontents
\newpage
\pagenumbering{arabic}
%Eventuell Fußnoten generieren
\section{Produktübersicht}
%kurze Übersicht über das Produkt
Das Produkt \enquote{DIbugger} soll dem Nutzer die Möglichkeit bieten, mehr als ein Programm gleichzeitig zu debuggen und interaktiv zu analysieren. \\
Dabei sollen die Konzepte eines herkömmlichen Debuggers, namentlich \glspl{Einzelschritt}, \glspl{Breakpoint} und Variableninspektion, erhalten bleiben und um zusätzliche Konzepte, die den Umgang mit zwei oder mehr Programmläufen erleichtern, erweitert werden. Zu diesen Konzepten gehören das Betrachten von sogenannten \glspl{Watch-Expression}, bei denen der Nutzer beispielsweise Differenz oder Quotient zweier Variablen aus den verschiedenen Programmen untersuchen kann. Der Fokus liegt hierbei auf der Unterstützung des Findens von relationalen Zusammenhängen in den vom Nutzer verfassten Programmen.
Die Sprache dieser Programme wird in Kapitel 12 näher definiert.
\vspace{0.7cm}
\begin{figure}[!h]
\centering
\includegraphics[width=0.6\textwidth]{logo_nongi.png}
\caption{Produktlogo}
\end{figure}

\section{Produkteinsatz}
Das Produkt unterstützt das Institut für theoretische Informatik am Karlsruher Institut für Technologie beim Führen von Beweisen zu relationalen Eigenschaften von Programmen. Hierbei soll die Möglichkeit des gleichzeitigen Debuggens der Programme dem Nutzer bei der Beweisführung helfen. \\
Verwendet wird das Produkt hierbei von wissenschaftlichen Mitarbeitern am Lehrstuhl \enquote{Anwendungsorientierte formale Verifikation - Prof. Dr. Beckert} am Karlsruher Institut für Technologie und soll in deren Büroumgebung zum Einsatz kommen. 

%Anwendungsbereiche, Zielgruppen, Betriebsbedingungen
 

\section{Produktumgebung}
%Software, Hardware, Orgware, Schnittstellen
Das Produkt läuft auf dem Rechner des Nutzers und benötigt keine Kommunikation mit außerhalb. Hierbei läuft das Produkt eventuell neben anderen Applikationen, kommuniziert jedoch nicht mit diesen.

\subsection{Software}
Da es sich bei dem Produkt um ein Java-Programm handelt, muss ein JRE (Java Runtime Environment) der Version 8 oder höher auf dem Rechner vorhanden sein oder mitinstalliert werden. \\
Das Produkt läuft sowohl auf Windows, als auch auf Mac OS und Linux (64bit empfohlen).

\subsection{Hardware}
An die Hardware des Rechners werden keine speziellen Anforderungen gestellt. Das Produkt läuft auf Rechnern mit mindestens einem 1 GHz Prozessor und 1 GB RAM.

\subsection{Schnittstellen}
Als Schnittstelle zum Nutzer selbst dient die graphische Benutzeroberfläche. \\ Es können sowohl Sprachkonfigurationsdateien, die die auf dieser Oberfläche angezeigten Texte beeinflussen, als auch Einstellungsdateien, die Einstellungen des Nutzers speichern, und Dateien, die Eingaben des Nutzers festhalten, geladen und persistent gespeichert werden, sodass eine Schnittstelle zum Dateisystem des Betriebssystems vorhanden ist. 

\newpage

\section{Produktfuntionen}
	 	\subsection{Funktionale Anforderungen}
 		\subsubsection{Musskriterien}
		\begin{itemize}
		\item[/FA10/] Das Produkt ist ein \gls{Debugger} für Programme, welche in der im Kapitel Ergänzungen spezifizierten Sprache geschrieben sind.
		\item[/FA20/] Im \gls{Debugmodus} kann der Benutzer \glspl{Schritt} (Steps) durchführen.
		\item[/FA30/] Es ist möglich, von den anderen Programmen unabhängige \glspl{Einzelschritt} in einem Programm auszuführen.
		\item[/FA40/] Der Benutzer kann die Schrittgröße für jedes Programm einzeln festlegen.
		\item[/FA50/] Bei einem \gls{Schritt} wird die vorgegebene Anzahl an Befehlen ausgeführt. Dabei werden die Befehle einer Funktion einzeln ausgeführt (automatisches Step-In). 
		\item[/FA60/] Der Benutzer kann durch \gls{Step-Out} eine Funktion verlassen.
		\item[/FA70/] Durch \gls{Step-Over} kann eine Funktion als einzelner auszuführender Befehl abgearbeitet werden.
		\item[/FA80/] Der Benutzer kann \glspl{Breakpoint} an Zeilen im Programm setzen.
		\item[/FA90/] Der Benutzer kann relationale Eigenschaften bezüglich Variablen als \glspl{bedingter Breakpoint} festlegen.
		\item[/FA100/] \Glspl{bedingter Breakpoint} können an vom Benutzer bestimmte Bereiche im Programm gebunden werden.
		\item[/FA110/] Der Benutzer kann relationale Eigenschaften bezüglich Variablen und arithmetische Terme über den Variablen als \glspl{Watch-Expression} festlegen.
		\item[/FA120/] \glspl{Watch-Expression} können an vom Benutzer bestimmte Bereiche im Programm gebunden werden.
		\item[/FA130/] Im \gls{Debugmodus} kann der Benutzer durch Auswahl der Option \enquote{Weiter} die Programme bis zum jeweils nächsten Breakpoint laufen lassen.
		\item[/FA140/] Das Produkt bietet die Möglichkeit, eine \gls{Konfigurationsdatei} für einen Lauf zu speichern. Diese beinhaltet festgelegte Eingabewerte, \glspl{Breakpoint}, \glspl{Watch-Expression}, Schrittgröße und die zu debuggenden Programme, sowie die aktuellen Befehle, an denen die Ausführung steht.
		\item[/FA150/] Die zu debuggenden Programme können direkt in die Textboxen des Produkts  geschrieben werden.
		\item[/FA160/] Die zu debuggenden Programme können direkt in die Textboxen des Produkts kopiert werden.
		\item[/FA170/] Die zu debuggenden Programm können aus einer Textdatei eingebunden werden.
		\item[/FA180/] Der \gls{Debugmodus} kann vom Benutzer abgebrochen werden. Dadurch kehrt der Benutzer zum \gls{Editiermodus} zurück.
		\item[/FA190/] Nach jedem \gls{Schritt}e oder \gls{Breakpoint} werden die aktuellen Variablenbelegungen angezeigt.
		\item[/FA200/] Die Variablenreihenfolge im Variableninspektor ist manuell veränderbar.
		\item[/FA210/] Im Variableninspektor können Variablen ausgeblendet werden.
		\item[/FA215/] Das Produkt ermöglicht die automatische Generierung von fehlenden Benutzerangaben für Eingabewerte.
		\end{itemize}

 		\subsubsection{Sollkriterien}
		\begin{itemize}
		\item[/FA220/] Das Produkt kann zufällige Vorschläge für Eingabewerte über einen Vorschlag-Button erstellen. Der Benutzer kann diese noch ändern.
		\item[/FA230/] Der Benutzer kann Variablen auswählen, von welchen jeder angenommene Wert gespeichert wird.
		\item[/FA240/] Bei Endlosschleifen wird automatisch abgebrochen. Die maximale Anzahl an Schleifendurchläufe kann vom Benutzer festgelegt werden (maximal 250).
		\item[/FA250/] Der Benutzer kann mehr als zwei Programme simultan debuggen.
		\item[/FA260/] Das Produkt kann Vorschläge für Eingabevariablen anhand der zu debuggenden Programme machen.
		\item[/FA270/] Das Produkt kann Vorschläge für \glspl{Watch-Expression} anhand der zu debuggenden Programme machen.
		\item[/FA280/] Das Produkt kann Vorschläge für \glspl{bedingter Breakpoint} anhand der zu debuggenden Programme machen.
		\end{itemize}

 		\subsubsection{Kannkriterien}
		\begin{itemize}
		\item[/FA290/] Die Datei des zu debuggenden Programms kann in das Textfeld hineingezogen werden.
		\item[/FA300/] Das Produkt kann, abhängig von der Zeilenanzahl der Programme, dem Benutzer die Schrittgröße(Step-Size) vorschlagen.
		\item[/FA310/] Der Benutzer kann einen Rückschritt durchführen.
		\item[/FA320/] Die, an Zeilen im Programm gebundenen, \glspl{Breakpoint} verschieben sich mit dem Programm, wenn dieser im \gls{Editiermodus} geändert wird.
		\end{itemize}		 		
 		
 		
 		\subsubsection{Abgrenzungskriterien}
 		\begin{itemize}
 		\item[/A10/] Das Produkt ist auf zu debuggende Programme mit maximal 100 Zeilen optimiert.
 		\item[/A20/] Das Produkt ist auf zu debuggende Programme mit maximal 100 Iterationen pro Schleife bzw. 100 Rekursionsaufrufe pro Funktion optimiert.
 		\item[/A30/] Das Produkt vergleicht nur Programme die in einem gemeinsamen Durchlauf gedebuggt wurden.
 		\item[/A40/] Das Produkt unterstützt eine maximale Zeilenbreite von 120 Zeichen.
 		\item[/A50/] Das Produkt ersetzt keinen Text-Editor. So hat es zum Beispiel kein Syntax-Highlighting und keine Auto-Vervollständigung.
 		\item[/A50/] Das Produkt ersetzt keine Versionskontrolle. Die Nutzerin ist selbst dafür verantwortlich, ihre Änderungen - zum Beispiel durch Kommentare - zu dokumentieren.
 		\end{itemize}
 		
 \newpage		
 		
	\subsection{Nichtfunktionale Anforderungen}
		\subsubsection{Produktdaten}
		\begin{itemize}
		
		
			\item[/PD10/] Konfigurationsdateien: \\
			Diese Dateien speichern eine Konfiguration des Debuggers. 
			Zu diesen gehören die Eingabewerte, Schrittgrößen, Variablenauswahl, Programmcode und Position beider Programme, aber nicht die Ausgabewerte. \\
			Weiter müssen alle \gls{Breakpoint} gespeichert werden. Dazu zählen sowohl gesetzte als auch bedingte Breakpoints. \Glspl{bedingter Breakpoint} benötigen keine Speicherung der Zeile, 			sondern die Speicherung eines Bereiches, zweier Variablen der Programmtexte und eines Operators. Dies gilt auch für die \glspl{Watch-Expression}.
			Zudem wird, falls die Datei aus dem \gls{Debugmodus} erzeugt wurde, der letzte Status aller Programme gespeichert, um diese nach späterem Laden weiter ausführen lassen zu können. 
			
			\item[/PD20/] Sprachdateien: \\
			Diese Datei speichert die Übersetzung der gesamten Benutzeroberfläche.
			Dazu gehören die Texte der GUI-Elemente und \glspl{Tooltip}.
			
			\item[/PD30/] Einstellungsdatei: \\
			Diese Datei speichert die zuletzt ausgewählte Sprache und die Adresse der \gls{Konfigurationsdatei}, welche zur zuletzt verwendeten Konfiguration passt.  
			\end{itemize}
			
			 
		\subsubsection{Produktleistungen}
		%Zeitverhalten, Genauigkeit, Fehlertoleranz
		\begin{itemize}
		\item[/PL10/] Zeitverhalten: \\
		Das Produkt ermöglicht das Hinzufügen von Eingabevariablen, Watch-Expressions, Schrittgröße und Breakpoints in Echtzeit. Das Ausführen von Schritten, Step-Over und Step-Out, sowie das Erreichen des nächsten Breakpoints, ist ebenfalls in Echtzeit möglich. \\
		Den Debugmodus zu starten dauert unter 5 Sekunden. 
		% Kann man das so lassen? Oder dauert Trace-Generierung länger?
		% Pop-Up mit "Trace wird generiert. Dies kann einen Moment dauern"
		\item[/PL20/] Genauigkeit: \\
		Da das Produkt alle primitiven Datentypen von Java unterstützt, ergibt sich für die vom Produkt angezeigten Variablenbelegungen die selbe Genauigkeit wie bei der Ausführung durch die JVM (Java Virtual Machine).
		\newpage
		\item[/PL30/] Fehlertoleranz: \\
		Durch automatische Warnung bei kritischen Eingaben (A10, A20) und Überprüfung der Semantik, ergibt sich eine hohe Fehlertoleranz bezüglich Benutzereingaben.
		Durch die automatische Generierung von fehlenden Benutzerangaben für Eingabewerte (FA215), wird der Start des Debugmodus zu jeder Zeit ermöglicht.
		\end{itemize}
		
		\subsubsection{Weitere nichtfunktionale Anforderungen}
		%Benutzbarkeit, Wartbarkeit, Erweiterbarkeit, Gesetze/Normen/Sicherheit/Urheberrecht, Robustheit
		\begin{itemize}
		\item[/NA10/]Erweiterbarkeit: \\
		Das Produkt ist, durch objektorientierten Entwurf, erweiterbar um zusätzliche Sprachen für die Benutzeroberfläche, sowie einen Interpreter für weitere Sprachen.
		\item[/NA20/]Wartbarkeit: \\
		Durch seinen objektorientierten Entwurf können auftretende Fehler leicht beseitigt werden.
		%\item[/NA25/]Robustheit: \\
		%weiß hier jemand was?
		\item[/NA30/]Urheberrecht: \\
		Das Produkt wird unter Open Source Lizenz entwickelt. Bei der Entwicklung wird das unter BSD-Lizenz veröffentlichte Antlr\textsuperscript{\textcopyright} verwendet.
		\item[/NA40/] Sicherheit: \\
		Da das Produkt keine Netzwerkverbindung besitzt, verbleiben die vom Benutzer eingegebenen Daten ausschließlich auf dem Rechner des Benutzers.
		\item[/NA50/]Benutzerfreundlichkeit: \\
		Durch das Hilfemenü werden dem Benutzer die wichtigsten Funktionen und deren Anwendung des Produkts erklärt. Erklärungen zu Bestandteilen der Benutzeroberfläche sind durch \glspl{Tooltip} abgedeckt. \\
		Durch die strikte Trennung der verschiedenen und Gruppierung der zusammengehörigen Elemente der Benutzeroberfläche ergibt sich ein übersichtliches Erscheinungsbild. 
		\end{itemize}
		

\section{Qualitätsanforderungen}

\subsection{Übersicht}
 \begin{tabular}{l||l|c|c|c} 
    & Produktqualität & Sehr relevant & Relevant & Weniger relevant \\
  \hline
  \hline
  \textbf{Benutzeroberfläche} &Verständlichkeit & & X &  \\
  %\cline{2-6}
  &Übersichtlichkeit & X & &\\
  %\cline{2-6}
  &Erlernbarkeit & & X & \\
  &Modifizierbarkeit & X && \\
  \hline
  \textbf{System} &Fehlertoleranz/ Stabilität & & X &  \\
  %\cline{2-6}
  &Zeit-/Ressourceneffizienz & & & X \\
  %\cline{2-6}
  &Richtigkeit &X & & \\
  &Erweiterbarkeit & & X &\\
  %\cline{2-6}
  &Installierbarkeit & & X &\\
 \end{tabular}
 
 \subsection{Benutzeroberfläche}
 
 Bei der Benutzeroberfläche wird besonders Wert auf Übersichtlichkeit, damit der Nutzer alle relevanten Daten und Einstellungen leicht findet, und Modifizierbarkeit, damit die Benutzeroberfläche leicht angepasst werden kann, falls das Produkt erweitert wird, gelegt. \\
Da das Produkt seinen Einsatz bei der wissenschaftlichen Arbeit findet, wird vom Nutzer eine gewisse Fähigkeit des Verstehens und Erlernens vorausgesetzt, sodass diese Punkte zwar relevant, aber nicht sehr relevant sind.

\subsection{System}

Da das Produkt als Unterstützung beim Führen von formalen Beweisen eingesetzt werden soll, ist die Richtigkeit aller Werte, die vom Produkt angezeigt und ausgerechnet werden, sehr relevant. \\
Um den Nutzer gut unterstützen zu können, ist eine gewisse Fehlertoleranz des Produktes bei falschen oder fehlenden Eingaben wichtig. Um gut eingesetzt werden zu können ist eine einfache Installation, die reibungslos funktioniert, ebenfalls wichtig. Jedoch wird bei diesen beiden Punkten wieder eine gewisse Selbstständigkeit des Nutzers vorausgesetzt, weshalb diese Punkte nicht so relevant wie die Richtigkeit des Produktes sind.
Da das Produkt in der ersten Version eventuell noch nicht alle möglichen Einsatzgebiete abdeckt, ist eine gute Erweiterbarkeit wichtig. \\
Da dem Nutzer moderne Rechner mit großer Rechenleistung, sowie viel Speicherplatz zur Verfügung stehen, ist die Ressourceneffizient nicht sehr relevant. 
%Ebenso muss der Nutzer bei zu komplizierten, zu untersuchenden Programmläufen damit rechnen, dass das Produkt nicht sehr Zeiteffizient ist, was jedoch durch die große Rechenleistung der verfügbaren Rechner ausgeglichen werden kann.
 

\newpage
\section{Anwendungsfälle und Szenarien}
\begin{figure}[h] 
  \centering
     \includegraphics[width=0.7\textwidth]{Anwendungsfalldiagramm}
  \caption{Anwendungsfalldiagramm}
  \label{fig:Bild1}
\end{figure}

In allen Anwendungsfällen ist der Benutzer der einzige Akteur

\begin{itemize}
    \item [/AF10/] Hinzufügen von Programmen:\\ 
	Der Benutzer möchte einen Programmcode hinzufügen, auf welchen er über die Dateiverwaltung
	seines Betriebssystems zugreifen kann.\\
	Dazu wählt er die Schaltfläche \enquote{Datei} der Menüleiste. In der Menüansicht wählt er anschließend die Fläche \enquote{Neues Programm hinzufügen}.\\
	Daraufhin öffnet sich die Dateiverwaltung seines Betriebssystems und der Benutzer fordert über diese den gewünschten Programmcode an.
	Das Programm erscheint in einem Eingabefenster.\\
	Hierbei ist folgende Ausnahme zu beachten: Besitzt das hinzuzufügende Programm mehr als 100 Zeilen, so benachrichtigt das Produkt den Benutzer über /A10/. Das Programm wird in jedem Fall hinzugefügt.\\
    
    \item [/AF20/] Ändern von Programmen:\\
    Der Benutzer möchte das von ihm hinzugefügte Programm ändern. Befindet er sich im \gls{Debugmodus}, muss er diesen zuvor abbrechen. \\
    Um den Code zu ändern kann der Benutzer das Programm direkt im Fenster durch hineinklicken bearbeiten. Außerdem kann der Benutzer auch weitere Programme hinzufügen oder Programme entfernen.
    
    \item [/AF30/] Setzen von Breakpoints:\\
    Der Benutzer möchte einen \gls{Breakpoint} hinzufügen. Hierbei hat er die Möglichkeit, einen \gls{Breakpoint} durch Doppelklick direkt in Zeilen im Programmcode zu setzen.\\
    Die zweite Möglichkeit ist das Setzen eines bedingten Breakpoints. Hierzu wählt der Benutzer die passende \enquote{+} Schaltfläche aus, fügt einen semantisch korrekten bedingten Breakpoint ein und wählt gegebenenfalls einen Bereich aus.
    
    \item [/AF40/] Hinzufügen von Watch-Expressions:\\
    Der Benutzer möchte eine \gls{Watch-Expression} bezüglich der von ihm hinzugefügten Programme hinzufügen. Dazu wählt er in der Benutzeroberfläche die Schaltfläche \enquote{+} unter \glspl{Watch-Expression} aus. Hier gibt er eine semantisch korrekte \gls{Watch-Expression} (siehe Kapitel 12) ein. Anschließend kann im selben Feld ein Bereich in einem oder mehreren der Programme angegeben werden, in dem das Produkt die Korrektheit der \gls{Watch-Expression} untersucht. Wird dieser Bereich leer gelassen, wird die Korrektheit der \gls{Watch-Expression} während des gesamten Durchlaufs überprüft.
    
    \item [/AF50/] Codes debuggen: \\
			Der Benutzer möchte zwei (oder mehr) Programmteile auf relationale Eigenschaften (z.B. Nicht-Interferenz oder Äquivalenz) untersuchen. Dazu fügt er die zu untersuchenden Programme in das Programm ein, setzt \glspl{Breakpoint} an relevanten Stellen und prüft seine Annahmen, wo die Programme sich unterscheiden könnten, mit Hilfe von \glspl{Watch-Expression} oder \glsplgen{bedingter Breakpoint}. Gegebenenfalls verändert er den Programmcode seiner Programme noch einmal. Dann startet er den \gls{Debugger}. Dieser läuft automatisch bis zum jeweils nächsten (bedingten) \gls{Breakpoint} durch. \\Der Benutzer hat dann die Möglichkeit, pro Zeile(n) oder pro \gls{Breakpoint} vorzugehen. Nach jedem Weitergehen werden ihm die Ergebnisse der Variablen und der Auswertung der \glspl{Watch-Expression} angezeigt. Am Ende des Debug-Vorgangs werden ihm die Ausgabewerte aller Programme angezeigt.
    
    \item [/AF60/] Speichern eines Durchlaufs: \\
    Der Benutzer möchte einen von ihm durchgeführten Debug-Lauf speichern, um ihn später zu wiederholen, an dieser Stelle fortzusetzen, oder an einen anderen Benutzer weitergeben. Dazu wählt er zu einem beliebigen Zeitpunkt, nachdem er mindestens einen zu debuggenden Programmcode hinzugefügt hat, im Dateimenü den Punkt \enquote{\gls{Konfigurationsdatei} speichern} aus. Anschließend kann der Benutzer den Speicherort der \gls{Konfigurationsdatei} über ein Pop-Up Fenster auswählen.\\

\end{itemize}
\section{Globale Testfälle}

\subsection{Basisfunktionen}

\begin{itemize}
	\item[/T010/] Öffnen des Produkts
	%\begin{itemize}
	%	\item Vorher: Desktop oder Terminal des Betriebssystems
	%	\item Aktion: Aufrufen des Produkts über Icon oder Terminal
	%	\item Nachher: Produkt öffnet sich in der Default-Ansicht.
	%	\frage{Öffnet das Produkt sich in Default? Wie sieht das aus?}
	%\end{itemize}
	
	\item[/T020/] Öffnen einer Textdatei
	%\begin{itemize}
	%	\item Vorher: \\
	%	Das Programm befindet sich im Editier-Modus und ... \\
	%%	b) es ist noch kein Programm geöffnet. \\
		%c) 
		%\item Aktion: Aufruf des File-Chooser-Dialogs im Menüpunkt \enquote{Datei}.
		%\item Nachher: Die ausgewählte Text-Datei
		%\\
		%\frage{Ist das im Editiermodus möglich? Öffnet es sich automatisch in ein neues Textfenster? Welche %Dateiformate sind zugelassen?}
	%\end{itemize}	

	\item[/T030/] Schließen des Produkts
	\item[/T040/] Öffnen einer Konfiguration
	\item[/T050/] Speichern einer Konfiguration
	
	\end{itemize}

\subsection{Grundsätzliche Debug-Funktionen}

\begin{itemize}

	\item[/T060/] Setzen eines \glspl{Breakpoint} synchron in allen Textfenstern
	\item[/T070/] Löschen eines \glspl{Breakpoint} in einem Textfenster
	\item[/T100/] Löschen aller \glspl{Breakpoint} eines Fensters
	\item[/T110/] Starten des \gls{Debugmodus}
	\item[/T120/] Abbrechen des \gls{Debugmodus}
	\item[/T130/] Halten des Debuggers an (bedingten) \glspl{Breakpoint}
	\item[/T140/] Verändern der Schrittgröße
	\item[/T150/] Einen \gls{Schritt} der gewählten Schrittlänge in allen Fenstern machen
	\item[/T160/] Einen \gls{Einzelschritt} in einem einzelnen Fenster machen
	\item[/T170/] Mittels \gls{Step-Over} eine Funktion nicht inspizieren
	\item[/T180/] Mittels \gls{Step-Out} aus einer Funktion zurückkehren
	\item[/T190/] Korrektes Ausgeben der Ausgabewerte
	\item[/T200/] Korrektes Auswerten der \glspl{Watch-Expression}
	\item[/T210/] Korrektes Anzeigen der Zwischenwerte von Variablen
	
\end{itemize}


\subsection{Watch-Expressions}

\begin{itemize}

	\item[/T220/] Hinzufügen einer \gls{Watch-Expression}
	\item[/T230/] Löschen einer \gls{Watch-Expression}
	\item[/T240/] Bearbeiten einer \gls{Watch-Expression}
	\item[/T250/] Hinzufügen einer Markierung
	\item[/T260/] Löschen einer Markierung
	\item[/T270/] Anzeigen einer Markierung
		
\end{itemize}
\subsection{Bedingte Breakpoints}

\begin{itemize}

	\item[/T280/] Hinzufügen eines bedingten Breakpoints
	\item[/T290/] Löschen eines bedingten Breakpoints
	\item[/T300/] Bearbeiten eines bedingten Breakpoints
	\item[/T310/] Hinzufügen einer Bereichsbindung
	\item[/T320/] Löschen einer Bereichsbindung
	\item[/T330/] Anzeigen einer Bereichsbindung
		
\end{itemize}

\newpage
\subsection{Variableneingabe}



\begin{itemize}

\item[/T330/] Angeben des Startwerts einer Variable
\item[/T340/] Angeben einer Wertespanne für den Startwert einer Variablen
\item[/T350/] Einfügen eines zufälligen Startwerts für eine Variable
\end{itemize}

\subsection{Menü-Funktionen}

Ein Item bezeichnet hier jeweils eine Einheit innerhalb eines Submenüs, zum Beispiel eine Watch-Expression innerhalb des Watch-Expression-Blocks oder ein Paar aus einer Variable und ihrem aktuellen Wert in der Variablenausgabe.

\begin{itemize}

	\item[/T360/] Verändern der Item-Reihenfolge
	\item[/T370/] Ein- und Ausblenden von Variablen
	\item[/T380/] Korrektes Anzeigen des Scrollbalkens
\end{itemize}


\newpage
\section{Systemmodelle}
%Architektur, Verhalten, usw
\begin{figure}[h] 
  \centering
     \includegraphics[width=1.0\textwidth]{Aktivitaetsdiagramm}
  \caption{Aktivitätsdiagramm}
  \label{fig:Bild2}
\end{figure}
\vspace{0.7cm}
Das Aktivitätsdiagramm stellt die möglichen Reihenfolgen der Interaktion des Benutzers mit dem Produkt dar. \\
Bindet der Benutzer direkt nach Start des Programms eine \gls{Konfigurationsdatei} eines früheren Laufs ein, kann er diesen Lauf direkt starten, oder vorher Änderungen an den Eingaben und Programmen vornehmen. \\
Die Aufteilung in \gls{Editiermodus} und \gls{Debugmodus} zeigt, dass das Ändern und Hinzufügen von Programmen und Ändern der Eingabevariablen nicht während des \gls{Debugmodus} möglich sind. Das Ändern von (bedingten) \glspl{Breakpoint}, \glspl{Watch-Expression} und der Schrittgröße ist auch im Debugmodus möglich, allerdings nur zwischen den ausgeführten Schritten und an \glspl{Breakpoint}. \\
Nach manuellem Abbruch oder nach kompletter Durchführung eines Debug-Laufs kehrt das Produkt zum \gls{Editiermodus} zurück. Die vorherigen Eingaben bleiben bestehen, sodass die Wiederholung des Laufs ohne Änderungen direkt möglich ist. Ebenso kann der Benutzer wieder Änderungen an den Eingabevariablen und den Programmen vornehmen.\\
Das Beenden des Produkts ist an jeder Stelle möglich.

\newpage

\begin{figure}[!ht]
	\centering
	\includegraphics[width=1.0\textwidth]{pakete}
	\caption{Paketdiagramm}
	\label{fig:Bild3} 

\end{figure}
\vspace{0.7cm}
	Während der Definitionsphase ergab sich das obige Paketdiagramm.\\ 
	Diese vorläufige Version des Paketdiagramms wird als Grundlage für den Entwurf des
	Produkts in der Entwurfsphase verwendet.
	
\newpage
\section{Benutzungsoberfläche}
%Gui-Skizzen, Erklärungen der Menüs, usw
\begin{figure}[!ht] 
    \vspace{-10pt}
    \centering
       \includegraphics[width=0.87\textwidth]{skizzeFull.eps}
       \caption{
         Benutzeroberfläche des Produktes im Editiermodus (oben) und im Debugmodus
         (unten)
       }
    \label{fig:Bild4}
\end{figure}

\newpage
    \subsection{Beschreibung der Oberfläche}
        Befindet sich das Produkt im \gls{Editiermodus}, so können die Eingabeprogramme über die 
        Eingabefenster bearbeitet werden.
        Durch Verändern des Textes im Bereich \enquote{Eingabewerte} können Werte der Eingangsvariablen
        spezifiziert, gelöscht und verändert werden. 
        Die Schaltflächen \enquote{\gls{Schritt}} und \enquote{Weiter}, sowie \enquote{\gls{Einzelschritt}} können in diesem Modus nicht betätigt
        werden. Betätigung der Schaltfläche mit dem grünen Pfeil verursacht den Übergang des Produkts in den Debugmodus.
        
        Befindet sich das Produkt im \gls{Debugmodus}, können die Eingabeprogramme nicht mehr
        bearbeitet werden.
        Die Schaltflächen \enquote{Schritt}, \enquote{Weiter} und \enquote{Einzelschritt}, sowie \enquote{Step Over} und \enquote{Step Out} können
        benutzt werden, um das Programm zu debuggen. \glspl{Breakpoint} können in den Eingabefenstern per Mausdruck gesetzt werden.
        Betätigung der Schaltfläche mit dem roten Viereck verursacht den Übergang in den Editiermodus.

        In beiden Modi können \glspl{bedingter Breakpoint} und \glspl{Watch-Expression} durch Betätigung der jeweiligen 
        \enquote{+}-Schaltflächen hinzugefügt werden. Über selbige Schaltflächen können Wirksamkeitsbereiche der \glspl{Watch-Expression} und \glspl{Breakpoint}
        spezifiziert werden.\\
     \subsection{Beschreibung der Menüs}
     Die Benutzeroberfläche bietet die folgenden Menüs:
     \begin{itemize}
     \item[Datei] Dieses Menü enthält die Menüeinträge \enquote{Neu}, \enquote{Konfigurationsdatei laden}, \enquote{Konfigrationsdatei speichern} und \enquote{Neues Programm hinzufügen}. Außerdem kann das Produkt über dieses Menü beendet werden.
     \item[Vorschläge] In diesem Menü befinden sich die Menüeinträge, um Vorschläge für \glspl{Watch-Expression}, \glspl{bedingter Breakpoint} und Eingabevariablen anzufordern.
     \item[Einstellungen] Über dieses Menü können Grundeinstellungen des Produkts, wie die Sprache der Benutzeroberfläche, angepasst werden.
     \item[Hilfe] Das Hilfemenü \enquote{?} stellt Hinweise zur Benutzung des Produkts zur Verfügung.
     \end{itemize}
       
\section{Anforderungen an die Entwicklungsumgebung}
Bei der Erstellung des Aktivitäts- und Anwendungsfalldiagramms wurde die Freie Version des Online-Diagramm-Editors \href{https://creately.com/}{Creately} verwendet.
Für die Entwicklung in Java werden die Java-Entwicklungsumgebungen IntelliJ\textsuperscript{\textcopyright} (2017.2.6) und Eclipse\textsuperscript{\textcopyright} Oxygen verwendet.

        
\section{Zeit- und Ressourcenplanung}
% Tabelle mit Phasendaten (Ideen sammeln, Einzelarbeit, Ideen zusammentragen, Überarbeitung, Abgabe Vorversion, Kolloquium/Abgabe Finalversion)
\subsection{Zeitliche Gesamtplanung}
\textit{06.11.2017 - 26.11.2017} Definitionssphase \\
\textit{27.11.2017 - 24.12.2017} Entwurfsphase \\
\textit{08.01.2018 - 04.02.2018} Implementierungsphase\\
\textit{19.02.2018 - 11.03.2018} Qualitätssicherungsphase\\
\textit{12.03.2018 - 25.03-2018} Abnahme und Präsentation

\subsection{Phasenverantwortliche:}
Definitionsphase: Chiara Staudenmaier\\
Entwurfsphase: Joana Plewnia, Benedikt Wagner\\
Implementierungsphase: Pascal Zwick\\
Qualitätssicherungsphase: Etienne Brunner\\
Präsentation/Abnahme: Ulla Scheler\\
\subsection{Vorraussichtliche zeitliche Feinplanung}
\subsubsection{Definitionsphase}
\textit{bis 08.11.} Sammeln der Inhalte\\
\textit{bis 15.11.} Formulierung der Punkte im Pflichtenheft in Einzelarbeit\\
\textit{bis 17.11.} Gemeinsame Überarbeitung\\
\textit{17.11. 11:30 Uhr} Abgabe der vor-finalen Version des Pflichtenhefts\\
\textit{bis 24.11.} Gemeinsame Überarbeitung\\
\textit{24.11. 11:30 Uhr} Abgabe der finalen Version des Pflichtenhefts \\

\subsubsection{Entwurfsphase}
\textit{bis 03.12.} Fertigstellung der Einteilung des Systems in Pakete und Unterpakete und Festlegung der Schnittstellen derer \\
\textit{bis 10.12.} Fertigstellung der Einteilung der Pakete in Klassen und definieren der Methoden und Attribute derer \\
\textit{bis 17.12.} Fertigstellung der Paket- und Klassenbeschreibungen und des vorläufigen Entwurfsdokumentes\\
\textit{22.12.} Abgabe des endgültigen Entwurfs

\subsubsection{Implementierungsphase}
\textit{bis 14.01.} Fertigstellung der Dateiverwalter und des Interpreters. Beginn an Front- und Backend\\
\textit{bis 21.01.} Fertige, aber noch nicht funktionelle Benutzeroberfläche. Bereitstellung einiger Methoden des Backends für diese\\
\textit{bis 28.01.} Vollständige Implementierung des Backends und ein funktionierendes Frontend\\
\textit{bis 04.02.} Ende und Abgabe der Implementierung des Programms

\subsubsection{Qualitätssicherungsphase}
\textit{bis 28.02.} Komponententest\\
\textit{bis 07.03.} Integrationstest\\
\textit{bis 11.03.} Systemtest, gegebenenfalls Abnahmetest\\

\subsubsection{Abnahme und Präsentation }
\textit{bis 16.03.} Einarbeiten der Anmerkungen aus dem letzten Kolloquium \\
\textit{bis NN} Anfertigung der Abschlusspräsentation
\newpage
\section{Ergänzungen}
%Sprache
\subsection{Sprache}
Die Programmiersprache, in der die zu debuggenden Programme verfasst sind, wird im Folgenden als die Sprache bezeichnet. 
\paragraph{Klassifikation der Sprache} Die Sprache ist prozedural und imperativ, nicht objektorientiert und nicht einrückungsbasiert.
\paragraph{Elemente der Sprache}
Die Sprache unterstützt die folgenden primitiven Datentypen:
\begin{itemize}
\item  32-bit Ganzzahlen: \texttt{int}
  \item  64-bit Ganzzahlen: \texttt{long}
 \item  32-bit IEEE 754 Fließkommazahlen: \texttt{float}
 \item   64-bit IEEE 754 Fließkommazahlen: \texttt{double}
  \item  Einzelnes Zeichen: \texttt{char}
  \item  Wahrheitswert: \texttt{boolean}
\end{itemize}
Zudem sind bis zu dreidimensionale Arrays dieser Datentypen möglich.
Ferner unterstützt die Sprache die folgenden Kontrollstrukturen:
\begin{itemize}
\item Funktionen und Prozeduren, also Unterprogramme mit oder ohne Rückgabewert.
\item Bedingte Ausführung: \texttt{if, else if, else}
\item Schleifen: \texttt{while}
\end{itemize}
Es muss in jedem Programm eine \texttt{main}-Routine vorhanden sein, von der die Ausführung ausgeht. Routinen, die aufgerufen werden, müssen darüber stehen. Kommentare können sowohl zeilenweise (\texttt{//}) als auch zeilenübergreifend (\texttt{/*Kommentar*/}) benutzt werden. Sämtliche Variablen müssen innerhalb einer Routine stehen. Auch Rekursion ist möglich.
\newpage

\paragraph{Syntax der Sprache}
Die Syntax der Sprache ist angeleht an gängige Sprachen wie C oder Java. Im folgenden Listing ist ein Beispielprogramm aufgeführt. 

\begin{verbatim}
void doUselessStuff() { //Prozedur ohne Rückgabe
    int a = 0;
}
float divide(float x, float y) { //Funktion mit Rückgabewert
    if(y != 0)	
        return x / y;
    return -1; //Rückgabe
}
int main(int j, int k)
{
    int a; //Deklaration
    a = 1; //Zuweisung
    long x = 100000L; 
    int b = 2; // Deklaration mit Initialisierung
    int[j + k ] myInts; \\Arraydeklaration
    char[4] myChars = {'a','b','c','d'};
    if(j < k) {
        int i = 0;
        while(i < j) {
            myInts[i] = 0; //Arrayzugriff
            i = i + 1;
        }	
    } else if(j == k) {
        return 0;
    } else
        return -1;
    doUselessStuff(); //Routinenaufruf
    float z = divide(3.0f*k / 1.1f);
    return z + j;
}
\end{verbatim}
\newpage
\subsection{Syntax der Watch-Expressions und bedingten Breakpoints}
Die Syntax der \gls{Watch-Expression} und \glsplgen{bedingter Breakpoint} ist durch folgende kontextfreie Ableitungsregeln gegeben: \\\\
<WatchExpression> $\rightarrow$ <BooleanExpression> | <Term>\\\\
<BedingterBreakpoint> $\rightarrow$ <BooleanExpression>\\\\<BooleanExpression> $\rightarrow$ <Term> < <Term> 
| <Term> > <Term> |\\ <Term> >= <Term>|<Term> <= <Term>| <Term> == <Term>| \\<Term> != <Term>\\\\
<Term> $\rightarrow$ <Term> / <Term> 
| <Term> * <Term> |\\ <Term> - <Term>|<Term> + <Term>| <Atom>\\\\

Wobei ein <Atom> ein fester Wert eines Datentyps (z.B. \texttt{5, 'c', true}) oder eine Variable der Form <Programmbezeichner>.<Variablenname> (z.B. \texttt{A.x} für Variable x in Programm A) ist. \\
Das heißt \glspl{Watch-Expression} werten sich zu einem beliebigen Wert aus, während sich \glspl{bedingter Breakpoint} immer zu einem Wahrheitswert auswerten.


\newpage
\printglossary[style=altlist, toctitle=Glossar]


\end{document}
\grid
